<a id="readme-top"></a>

<!--
<details>
  <summary>Table of Contents</summary>
  <ol>
    <li>
      <a href="#about-the-project">About The Project</a>
      <ul>
        <li><a href="#built-with">Built With</a></li>
      </ul>
    </li>
    <li>
      <a href="#getting-started">Getting Started</a>
      <ul>
        <li><a href="#prerequisites">Prerequisites</a></li>
        <li><a href="#installation">Installation</a></li>
      </ul>
    </li>
    <li><a href="#usage">Usage</a></li>
    <li><a href="#roadmap">Roadmap</a></li>
    <li><a href="#contributing">Contributing</a></li>
    <li><a href="#license">License</a></li>
    <li><a href="#contact">Contact</a></li>
    <li><a href="#acknowledgments">Acknowledgments</a></li>
  </ol>
</details>
-->

[//]: # (Some comment)

| Name | URL | LOGO |
|:- |:-:| -:|
|Java   |https://www.java.com/   |<img src="https://www.oracle.com/a/tech/img/rc10-java-badge-3.png" width="50" />   |
|Spring    |https://spring.io/     |<img src="https://spring.io/img/spring.svg" width="50" />     |
|Micronaut      |https://micronaut.io/     |<img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQBJBIDk2Tng_lwEapAcS2m3TzJlym-4ak7EQ&s" width="50" />      |
|      |     |      |
|      |     |      |

# About The Project

My First test  Repo for GIT

### Built With

This section should list major updates

* RateLimiter: ограничение пропускной способности
* Bulkhead: изоляция ресурсов
* Timeout: ограничение времени ожидания
* Fallback: запасной ответ
* CircuitBreaker: разрыв цепи

### Getting Selected

Now it's the choice that 

### Roadmap

<!-- Some new comment! -->

*Here we have mentioned all the concepts required to become a backend developer and the correct flow of learning them.*

- [x] Add Changelog
- [x] Add back to top links
- [x] Add text
- [ ] Add tasks
- [ ] Add test
    - [ ] English
    - [ ] Russian
    - [ ] Spanish

### Installation

В сложных распределенных системах микросервисной архитектуры отказ или перегрузка одного компонента может привести к каскадному отказу всей системы. Например, если сервис A зависит от медленного сервиса B, а B начинает отвечать с сильной задержкой или вовсе не отвечает, то все запросы к A будут зависать и занимать потоки, пока не достигнут таймаута. Такая ситуация описана в Vinsguru: “Сервис D может не отвечать из-за сетевой задержки, что замедлит все связанные сервисы и заблокирует потоки вплоть до сервиса A”. Без защитных механизмов коллизия или перегрузка одного микросервиса исчерпывает ресурсы клиентов (потоки, соединения и т.д.) и приводит к отказам в других сервисах. Согласно документации Microsoft, 
> “чрезмерная нагрузка или сбой в сервисе затрагивают всех его клиентов: ресурсы могут быть исчерпаны, и клиент больше не сможет обращаться к другим сервисам”.

Такие проблемы, называемые “каскадными отказами”, возникают по разным причинам: медленная сеть, сбои зависимостей, неожиданные пиковые нагрузки. Чтобы микросервисы оставались устойчивыми и отвечали на запросы даже при частичных неполадках, используются паттерны отказоустойчивости. Ключевые из них – RateLimiter, Bulkhead, Timeout, Fallback и CircuitBreaker. Они позволяют ограничить и изолировать проблему, защитив сервисы от каскадных отказов. В этой статье мы подробно разберем каждый паттерн: зачем он нужен, какую проблему решает и как реализуется (на примере Spring Boot с Resilience4j и Hystrix). Также сравним Resilience4j и Hystrix, их особенности и области применения.

<p align="right">
  <a href="#readme-top">Back to Top</a>
</p>

### RateLimiter

Зачем нужен: RateLimiter (ограничение скорости запросов) позволяет предохранить сервис от перегрузки большим числом одновременных запросов. Если на сервис обрушивается лавина вызовов, он может начать отказывать или серьезно тормозиться. RateLimiter контролирует пропускную способность и при необходимости отбрасывает лишние запросы. По сути, это предотвращает ситуацию, когда слишком много клиентов одновременно бьют по одному сервису, делая его недоступным для всех. Паттерн помогает поддерживать доступность: сервис продолжает обрабатывать максимум запросов, заданный заранее, а остальные либо отклоняются, либо ставятся в очередь.

***

Что делает: RateLimiter особенно полезен при пиковых нагрузках или в сценариях с агрессивными клиентами. Он защищает сервис, контролируя throughput – число запросов за период. Например, если сервис может обрабатывать максимум 100 запросов в секунду, RateLimiter задаёт эту скорость. Если приходят лишние запросы, сервис сразу возвращает ошибку о превышении лимита или временно задерживает обработку. Такой подход гарантирует, что сервис не упадет под напором трафика. Как написано в блоге Vinsguru, > “Rate Limiter помогает сделать сервисы высокодоступными, просто ограничивая число запросов, которые мы можем выполнить в заданное время”.

Как работает: В Resilience4j RateLimiter делит время на равные циклы (time buckets) и выдает фиксированное число разрешений (permits) на каждый цикл. Например, в каждой минуте даётся 100 разрешений; как только они исчерпаются, последующие вызовы либо отклоняются, либо ждут начала следующего периода. При исчерпании лимита можно настроить две стратегии: отклонять новые запросы или ставить их в очередь. Документация Resilience4j описывает: 
> “Вы можете просто отклонять слишком много запросов, либо строить очередь для их последующего выполнения, либо комбинировать оба подхода”.

<p align="right">
  <a href="#readme-top">Back to Top</a>
</p>

### Bulkhead

Зачем нужен: ***Bulkhead (перегородка)*** – паттерн, призванный изолировать сбой одного компонента от других. Название дано по аналогии с отсеком-толщиной корабля: если корпус пробит, вода затопит лишь один отсек, а корабль останется на плаву. В контексте микросервисов bulkhead изолирует ресурсы (например, потоки или соединения) для разных зависимостей или клиентов. Это предотвращает ситуацию, когда зависший или медленный сервис “душит” все потоки клиента. Например, если клиент A вызывает сервис B и сервис C параллельно, и B начинает тормозить, мы хотим, чтобы большая часть потоков продолжала обрабатывать вызовы к C.

[![Alternate text](https://i0.wp.com/proselyte.net/wp-content/uploads/2025/05/n4.png)](https://proselyte.net/protective-patterns/)

Что делает: Bulkhead препятствует исчерпанию общих ресурсов. Как объясняет Microsoft, в стандартном сценарии большое количество неудачных запросов к одному сервису может “исчерпать соединения или потоки в клиенте; затем клиент перестаёт отправлять запросы не только к проблемному сервису, но и ко всем остальным”. Решение – выделять “отсеки” ресурсов. Например, иметь отдельный пул потоков или семафор для обращений к каждому сервису. Тогда если один отсек (сервис B) полностью занят, остальные (сервис A, C) все равно работают независимо. Этот подход сохраняет функциональность части системы при частичном сбое.

Как работает: В Resilience4j доступны два варианта реализации bulkhead: 
1. SemaphoreBulkhead (семафорный) и FixedThreadPoolBulkhead (фиксированный пул потоков).
2. В первом случае используется семафор – простой механизм, ограничивающий число одновременно выполняющихся вызовов (заявок на семафор).
3. Hystrix может работать аналогично: он предлагает как семафорную изоляцию, так и изоляцию потоков. Однако по умолчанию Hystrix использует изолированный пул потоков для каждой команды, что обеспечивает полную разгрузку исходного потока и таймаут из того пула. Resilience4j же по умолчанию использует семафор, “в отличие от Hystrix не создавая теневой (shadow) пул потоков”. Это упрощает интеграцию – нет лишнего потока, который нужно настраивать.

Например, в Resilience4j можно прописать аннотацию:

```java
@Bulkhead(name = "externalService", type = Bulkhead.Type.SEMAPHORE)
public String callExternal() {
    // код вызова внешнего сервиса
}
```
Это ограничит число параллельных вызовов “callExternal()” до значения из конфигурации “bulkheadConfig.maxConcurrentCalls”. Если лимит исчерпан, Resilience4j бросит исключение “BulkheadFullException”. Гибридно можно использовать пул потоков:

```java
@Bulkhead(name = "externalService", type = Bulkhead.Type.THREADPOOL)
public String callExternal() {
    // код вызова внешнего сервиса
}
```

а это, в свою очередь, создаст отдельный пул на фиксированное число потоков. В Hystrix настройка похожа, но делается через “@HystrixCommand” с указанием “threadPoolKey” и размера пула, либо напрямую через свойства пула.

Как пишет автор руководства по микросервисам К. Эрландссон (StackOverflow), “Hystrix ограничивает число параллельных вызовов к компоненту, таким образом ограничивая количество потоков, ожидающих ответа“. То есть при возникновении больших задержек у компонента C с “bulkhead” в 10 потоков из 30 только 10 потоков заблокируются на ожидание C, а остальные 20 будут обслуживать другие запросы к A и B.

Преимущества: Bulkhead позволяет “сохранить часть функциональности” при проблемах: другие сервисы продолжат отвечать, даже если один зависает. Это критично для систем с множеством взаимозависимых сервисов.

### Timeout

Зачем нужен: Timeout (таймаут) нужен, чтобы не ждать клиента слишком долго и освободить его ресурсы. В распределённых системах любой сетевой вызов может “зависнуть” из-за непредвиденных задержек или зависших зависимостей. Без таймаута поток, выполняющий запрос, может блокироваться неопределённо долго, что приводит к исчерпанию пулов потоков и общему застою. Как отмечает автор блога Vinsguru, даже такие гиганты как Google могут иногда испытывать замедление. В случае цепочки вызовов, например A -> B -> C, если C не отвечает, то A и B будут ждать и постепенно утратят ресурсы. “Необходимо предусмотреть замедление сервисов и устанавливать таймаут для любого сетевого вызова, чтобы основные сервисы продолжали корректно работать и оставались отзывчивыми, даже когда зависимость недоступна“. Это помогает избежать блокировки критичных потоков.

![Alternate text](https://i0.wp.com/proselyte.net/wp-content/uploads/2025/05/b2.png)

Что делает: Применение таймаутов гарантирует, что любой долгий запрос прервётся по прошествии определённого времени. После срабатывания таймаута можно перейти к Fallback или бросить исключение дальше. Без таймаута попытка обратиться к зависшим сервисам может “дожить до миллиона лет” – т.е. на долгие секунды или минуты заблокировать поток. Таймаут предотвращает зависание всей системы и позволяет ей оперативно реагировать на проблемы. Это также снижает задержку на обработку запросов в целом (мы не ждем бесконечно).

Как работает: В Spring Boot и Resilience4j для асинхронных операций предусмотрен модуль TimeLimiter, который можно использовать для задания максимального времени исполнения метода. Он может работать совместно с “CompletableFuture” или “Mono/Flux”. При переполнении таймаута Resilience4j либо отменит вызывающий “Future” (если “cancelRunningFuture=true”), либо бросит исключение “TimeoutException”. Пример простейшей конфигурации TimeLimiter:

```java
TimeLimiterConfig config = TimeLimiterConfig.custom()
    .timeoutDuration(Duration.ofSeconds(2))
    .cancelRunningFuture(true)
    .build();
TimeLimiter timeLimiter = TimeLimiter.of(config);
```

В Spring Boot с аннотацией можно написать:

```java
@TimeLimiter(name = "myService")
public CompletableFuture<String> callServiceWithTimeout() {
    return CompletableFuture.supplyAsync(() -> {
        // длительная операция
    });
}
```

Если операция не завершится за 2 секунды, вызов прекратится.

В Hystrix таймаут задаётся через свойства “execution.isolation.thread.timeoutInMilliseconds” (при использовании изоляции потоков) или “semaphore.timeoutInMilliseconds”. Так или иначе, механизм схож: после исчерпания времени вызывает fallback или бросает исключение.

Преимущества: Таймауты не дают запросам “вечность” держать ресурсы. Как указывает Vinsguru, это позволяет “ядру сервисов всегда работать, даже когда зависимые сервисы недоступны”. Это особенно важно в системах, где “нет ничего стабильнее перемен” – при любых сетевых сбоях и авариях таймаут гарантирует быстроту отказа, не блокируя всё подряд.

<p align="right">
  <a href="#readme-top">Back to Top</a>
</p>

### Fallback: запасной ответ

Зачем нужен: Fallback (запасной механизм) нужен для того, чтобы система могла вернуть осмысленный результат или выполнить альтернативную логику вместо полного сбоя. Если основной запрос к сервису не удался (ошибка, исключение, открыт CircuitBreaker), логично попытаться выдать запасной ответ – например, взять данные из кэша, вернуть “заглушку” или обратиться к дежурному сервису. Fallback повышает удобство для клиента и надёжность системы: вместо “500 Internal Error” мы возвращаем определённый ответ или пустой результат.

![Some text](https://i0.wp.com/proselyte.net/wp-content/uploads/2025/05/b1.png)

Рис. 4. Диаграмма последовательности: при сбое вызова внешний сервис отключается Circuit Breaker’ом, и клиентский код переключается на fallback-метод.
Что делает: Этот паттерн предотвращает резкие провалы функциональности. После исчерпания повторов (Retry) или при открытом CircuitBreaker он срабатывает и “спасает” процесс. Паттерн Fallback описан так: “Fallback предоставляет альтернативное решение при неудачном запросе к сервису. Когда Circuit Breaker срабатывает и переходит в открытое состояние, выполняется логика fallback вместо основной. Такая логика обычно делает минимум работы и возвращает запасное значение“. Например, если база данных недоступна, можно вернуть кэшированные данные или заранее подготовленный ответ. Главное, чтобы сами методы fallback не падали: по определению fallback должен иметь очень низкий шанс на ошибку, так как он вызывается после уже одной неудачи системы.

Как работает: В Spring Boot с Resilience4j и Hystrix fallback реализуется через дополнительные методы. В Resilience4j (при аннотациях) указывают “fallbackMethod”. Каждая ошибка, включая “CallNotPermittedException” (когда открыта цепь) или любое другое исключение, перенаправляется в метод-обработчик, подобно блоку “try/catch”. Пример:

```java
@CircuitBreaker(name = "backend", fallbackMethod = "fallbackHandler")
public String callExternalService() {
    // попытка вызвать внешний сервис
}

public String fallbackHandler(Exception e) {
    return "Временный ответ";
}
```

Здесь при любой ошибке или при открытом CircuitBreaker будет вызван “fallbackHandler”. Важный момент: в Resilience4j методы-обработчики нужно располагать в том же классе и по сигнатуре они принимают исходные параметры плюс одно исключение. Если параметр-исключение совпадает с реальным исключением, сработает самый подходящий метод.

В Hystrix используется аннотация “@HystrixCommand” с указанием “fallbackMethod”. Пример из Spring Cloud Netflix Hystrix:

```java
@HystrixCommand(fallbackMethod = "defaultStores")
public Object getStores(Map<String, Object> params) { 
    // код, могущий выкинуть исключение
}
public Object defaultStores(Map<String, Object> params) {
    return Collections.emptyList(); // запасной ответ
}
```

Spring Cloud автоматически проксирует bean с “@HystrixCommand”, подключая его к Hystrix Circuit Breaker. Таким образом, при отказе метода будет вызван “defaultStores” вместо ошибки.

Особенности: Fallback может быть любым – обращением к другому сервису, статическим данными или просто ошибкой типа “сервис временно недоступен”. Главное, чтобы сам fallback не создавал большого навеса работы. Иногда используют стратегию silent fail (просто возвращают null или пустой ответ, если данные не критичны) или fail-fast (сразу возвращают 5xx, если данные обязателены).


### Circuit Breaker

Наиболее популярный инструмент данной библиотеки, в большинстве случаев используют только его

Думаю многие знакомы с данным паттерном, опишу его кратко

В ситуациях когда приложение-сервер начинает отвечать на запросы ошибками (или отвечает слишком медленно) несколько раз подряд, circuit breaker на стороне приложения-клиента это понимает и на некоторое время прерывает отправку запросов (размыкается), и вместо отправки запросов в это время возвращает типовой ответ (fallback) или просто выбрасывает исключение

Таким образом мы даем приложению-серверу немного времени на передышку и не спамим его запросами. Это особенно актуально в высоконагруженных системах, где за секунду могут отправляться тысячи запросов

Circuit Breaker имеет 3 состояния:

* **CLOSED** (замкнут) - поведение приложения не меняется, все работает в штатном режиме

* **OPEN** (разомкнут) - цепочка вызовов разорвана

* **HALF_OPEN** (частично разомкнут) - переходит в данное состояние из OPEN после таймаута, половина запросов отправляется на конечный сервис, для проверки работоспособности, если все хорошо переходит в CLOSED, иначе в OPEN

Также есть 2 специальных состояния:

* **DISABLED** - отключен

* **FORCED_OPEN** - принудительно OPEN

Пример использования:

```java
@CircuitBreaker(name = "myCircuitBreaker", fallbackMethod = "recoverMethod")
public MyResponse sendRequest() {
    return ...;
}

private MyResponse recoverMethod(Exception ex) {
    log.warn(ex.getMessage(), ex);

    return ...;
}
```

В параметре name является обязательным, в нем указывается имя circuitBreaker'а, по которому задаются настройки

Параметр fallbackMethod необязательный, в него мы передаем имя метода, который будет исполнен вместо текущего метода если circuitBreaker находится в разомкнутом состоянии OPEN. Если же данный параметр не задан, то будет выброшено исключение CallNotPermittedException

fallback метод должен соответствовать нескольким критериям:
- возвращать тот же тип данных, что и исходный метод
- принимать исключение в качестве параметра, а также может принимать те же параметры что и основной метод (не обязательно), но не больше параметров чем у исходного метода

Обязательно тестируйте работоспособность fallback методов, поскольку если он написан неправильно, то ошибка будет выброшена только в момент вызова этого метода уже во время работы приложения

resilience4j использует скользящее окно (sliding window) по которому делает вывод об изменении состояния circuitBreaker'а

Скользящее окно может быть двух типов:

* **COUNT_BASED** - собирает последние N запросов

* **TIME_BASED** - собирает запросы за последние N секунд

Это довольно важный момент, по умолчанию тип COUNT_BASED и если ваш сервис редко отправляет запросы, то есть вероятность что circuitBreaker может сработать когда этого не ожидаешь, например за последние несколько дней периодически появлялись ошибки, но запросов было так мало, что процент ошибок превысил пороговое значение и circuitBreaker откроется с появлением очередной ошибки, в таких случаях (количество отправляемых запросов небольшое) лучше пользоваться TIME_BASED окном

Настройки circuitBreaker'а:

* **failureRateThreshold** - порог невалидных запросов, по ум. 50

* **slowCallRateThreshold** - порог медленных запросов (запрос считается медленным, если выполняется дольше, чем указано в настройке slowCallDurationThreshold), по ум. 100

* **slowCallDurationThreshold** - время, по которому определяется что запрос является медленным, по ум. 60000 мс

* **permittedNumberOfCallsInHalfOpenState** - количество запросов, которые необходимо выполнить в HALF_OPEN состоянии, по ум. 10

* **maxWaitDurationInHalfOpenState** - время в течение которого CircuitBreaker остается в HALF_OPEN состоянии, перед тем как переключится в OPEN, по ум. значение 0, значит время не ограничено

* **slidingWindowType** - два возможных значения COUNT_BASED, TIME_BASED, по ум. COUNT_BASED

* **slidingWindowSize** - размер sliding window, при COUNT_BASED - обозначает количество запросов, при TIME_BASED - количество секунд, по ум. 100

* **minimumNumberOfCalls** - минимальное количество вызовов, по которым принимается решение о переключении состояния. Если тип скользящего окна TIME_BASED, то данное минимальное количество вызовов должно быть выполнено за указанный период в slidingWindowSize, по ум. 100

* **waitDurationInOpenState** - время, в течение которого состояние остается OPEN, после чего переходит в HALF_OPEN, по ум. 60000 мс

* **automaticTransitionFromOpenToHalfOpenEnabled** - в значении true автоматически переводит в HALF_OPEN состояние, не ожидая следующего вызова, но для этого запускается отдельный поток, который выполняет перевод состояния, по ум. false

* **recordExceptions** - список исключений, при выбросе которых выполнение метода будет считаться невалидным, по умолчанию при выбросе любых исключений считается невалидным, по ум. пустой

* **ignoreExceptions** - список исключений, которые будут явно проигнорированы, при определении невалидных запросов. При выбросе данных исключений они не будут расценены ни как валидные, ни как невалидные, по ум. пустой

* **recordFailurePredicate** - условие при котором исключение будет расценено как невалидный ответ. по ум. - throwable -> true

* **ignoreExceptionPredicate** - условие при котором исключение будет проигнорировано, по ум. - throwable -> false

Данные настройки можно задать как для всех circuitBreaker'ов сразу, так и для каждого по отдельности:

```
resilience4j:
  circuitbreaker:
    configs:
      default:
        slidingWindowSize: 100
        permittedNumberOfCallsInHalfOpenState: 10
        slowCallDurationThreshold: 4s
        slowCallRateThreshold: 90
        failureRateThreshold: 50
        waitDurationInOpenState: 10s
        minimumNumberOfCalls: 10
    instances:
      myCircuitBreaker:
        baseConfig: default
        waitDurationInOpenState: 20s
      myCircuitBreaker2:
        baseConfig: default
        waitDurationInOpenState: 30s
```

myCircuitBreaker - это тот самый name, который мы задаем в аннотации

Также circuitBreaker отдает метрики микрометра, здесь можно скачать дашборд grafana для мониторинга.

### Retry

Позволяет выполнять повторные попытки в случае возникновения ошибок

Настройки retry:

* **maxAttempts** - максимальное количество попыток, включая первый вызов, по ум. 3

* **waitDuration** - фиксированное время между попытками, по ум. 500 мс

* **intervalFunction** - функция определения интервала, по ум. numOfAttempts -> waitDuration

* **intervalBiFunction** - также функция определения интервала, но в качестве аргументов принимает количество попыток и результат выполнения метода, по ум. (numOfAttempts, Either<throwable, result>) -> waitDuration

* **retryOnResultPredicate** - условие по которому должен быть выполнен retry, при определенном результате, по ум. result -> false

* **retryExceptionPredicate** - условие по которому должен быть выполнен retry, при ошибке, по ум. throwable -> true (при всех ошибках)

* **retryExceptions** - список ошибок, по которым должен быть выполнены retry, по ум. пустой

* **ignoreExceptions** - список игнорируемых ошибок, по ум. пустой

* **failAfterMaxAttempts** - следует ли выбрасывать MaxRetriesExceededException, в случае превышения количества попыток, по ум. false

При использовании с webflux подставляет в реактивную цепочку оператор .retry()

Пример использования:

```java
@Retry(name = "myRetry")
public Mono<MyResponse> sendRequest() {
    ...
}
```

```
resilience4j.retry:
  configs:
    default:
      maxAttempts: 3
      waitDuration: 100ms
      retryExceptions:
        - org.springframework.web.client.HttpServerErrorException
        - java.util.concurrent.TimeoutException
        - java.io.IOException
      ignoreExceptions:
        - io.github.robwin.exception.BusinessException
```

Обратите внимание, что в настройках не обязательно прописывать name конкретного инструмента, если вам достаточно default конфигурации

Данный инструмент удобен, если в вашем коде в нескольких местах нужно выполнять повторные попытки с одинаковыми условиями, поскольку можно один раз задать все нужные настройки и использовать аннотацию в нескольких местах

Если же вы выберете spring retry или оператор .retry() в webflux, то вам каждый раз придется задавать все условия выполнения повторных попыток в месте использования этих

Также как и circuitBreaker отдает метрики, поэтому можно настроить мониторинг.

### Rate Limiter

Позволяет ограничить количество вызовов метода за указанный промежуток времени, при превышении количества вызовов остальные будут ожидать своей очереди в течение заданного таймаута

Например мы хотим чтобы какой-то внешний сервис нельзя было вызывать более 100 раз в секунду, и если мы вдруг превысили данную нагрузку, то потоки будут ждать, либо вернуть заданный ответ (fallback), либо выбросят ошибку

Настройки rateLimiter:

* **timeoutDuration** - время в течение которого поток ждет разрешения, по ум. 5 сек

* **limitRefreshPeriod** - период за который ограничивается число вызовов, по ум. 500 наносекунд

* **limitForPeriod** - предельное число вызовов за время указанное в limitRefreshPeriod, по ум. 50

Пример использования:

```java
@RateLimiter(name = "myRateLimiter", fallbackMethod = "myFallbackMethod")
public Mono<SomeResult> doSomething() {
    ...
}

private Mono<SomeResult> myFallbackMethod(Exception ex) {
    log.warn(ex.getMessage(), ex);
    return Mono.error(...);
}
```

```
resilience4j.rateLimiter:
  configs:
    default:
      timeoutDuration: 5s
      limitForPeriod: 10
      limit-refresh-period: 1s
```

В данном примере если количество вызовов метода превысит 10 за секунду, то вызывающие потоки будут ждать 5 секунд, перед тем как попытаться снова вызвать метод

Если количество вызовов метода превысит limitForPeriod и потоки не дождутся своей очереди, то будет выброшено исключение RequestNotPermitted или вызван fallback метод, если мы его задали

Использует два возможных механизма, на основе атомиков и на основе семафора, первый используется по умолчанию и переключиться на второй нет никакой возможности

Во внутренней реализации с использованием webflux добавляет .delaySubscription() - т.е. откладывает именно подписку на издателя (Mono/Flux), а не откладывает пропускание самих элементов

![Another text](https://habrastorage.org/r/w1560/getpro/habr/upload_files/0fb/2e4/a2a/0fb2e4a2a61e2b592ab54d773217fa03.png)

Поэтому если ваш метод не создает Mono/Flux, а например принимает его в качестве параметра, добавляет в цепочку операторы и возвращает в ответе, то работать RateLimiter будет не так как вы ожидаете, здесь подробно закапываться в эту тему не буду, достаточно понимать что в таком подходе его лучше не использовать.


### Links

* [Защитные паттерны](https://proselyte.net/protective-patterns/)

* [Backend roadmap](https://www.geeksforgeeks.org/websites-apps/backend-developer-roadmap/ "Click to navigate a new roadmap")
* [Использование resilience4j со Spring Boot](https://habr.com/ru/articles/793550/)
