# About The Project

My First test  Repo for GIT

### Built With

This section should list major updates

* RateLimiter: ограничение пропускной способности
* Bulkhead: изоляция ресурсов
* Timeout: ограничение времени ожидания
* Fallback: запасной ответ
* CircuitBreaker: разрыв цепи

### Getting Selected

Now it's the choice that 

### Roadmap

*Here we have mentioned all the concepts required to become a backend developer and the correct flow of learning them.*

### Installation

В сложных распределенных системах микросервисной архитектуры отказ или перегрузка одного компонента может привести к каскадному отказу всей системы. Например, если сервис A зависит от медленного сервиса B, а B начинает отвечать с сильной задержкой или вовсе не отвечает, то все запросы к A будут зависать и занимать потоки, пока не достигнут таймаута. Такая ситуация описана в Vinsguru: “Сервис D может не отвечать из-за сетевой задержки, что замедлит все связанные сервисы и заблокирует потоки вплоть до сервиса A”. Без защитных механизмов коллизия или перегрузка одного микросервиса исчерпывает ресурсы клиентов (потоки, соединения и т.д.) и приводит к отказам в других сервисах. Согласно документации Microsoft, “чрезмерная нагрузка или сбой в сервисе затрагивают всех его клиентов: ресурсы могут быть исчерпаны, и клиент больше не сможет обращаться к другим сервисам”.

Такие проблемы, называемые “каскадными отказами”, возникают по разным причинам: медленная сеть, сбои зависимостей, неожиданные пиковые нагрузки. Чтобы микросервисы оставались устойчивыми и отвечали на запросы даже при частичных неполадках, используются паттерны отказоустойчивости. Ключевые из них – RateLimiter, Bulkhead, Timeout, Fallback и CircuitBreaker. Они позволяют ограничить и изолировать проблему, защитив сервисы от каскадных отказов. В этой статье мы подробно разберем каждый паттерн: зачем он нужен, какую проблему решает и как реализуется (на примере Spring Boot с Resilience4j и Hystrix). Также сравним Resilience4j и Hystrix, их особенности и области применения.

### RateLimiter

Зачем нужен: RateLimiter (ограничение скорости запросов) позволяет предохранить сервис от перегрузки большим числом одновременных запросов. Если на сервис обрушивается лавина вызовов, он может начать отказывать или серьезно тормозиться. RateLimiter контролирует пропускную способность и при необходимости отбрасывает лишние запросы. По сути, это предотвращает ситуацию, когда слишком много клиентов одновременно бьют по одному сервису, делая его недоступным для всех. Паттерн помогает поддерживать доступность: сервис продолжает обрабатывать максимум запросов, заданный заранее, а остальные либо отклоняются, либо ставятся в очередь.

***

Что делает: RateLimiter особенно полезен при пиковых нагрузках или в сценариях с агрессивными клиентами. Он защищает сервис, контролируя throughput – число запросов за период. Например, если сервис может обрабатывать максимум 100 запросов в секунду, RateLimiter задаёт эту скорость. Если приходят лишние запросы, сервис сразу возвращает ошибку о превышении лимита или временно задерживает обработку. Такой подход гарантирует, что сервис не упадет под напором трафика. Как написано в блоге Vinsguru, “Rate Limiter помогает сделать сервисы высокодоступными, просто ограничивая число запросов, которые мы можем выполнить в заданное время”.

Как работает: В Resilience4j RateLimiter делит время на равные циклы (time buckets) и выдает фиксированное число разрешений (permits) на каждый цикл. Например, в каждой минуте даётся 100 разрешений; как только они исчерпаются, последующие вызовы либо отклоняются, либо ждут начала следующего периода. При исчерпании лимита можно настроить две стратегии: отклонять новые запросы или ставить их в очередь. Документация Resilience4j описывает: “Вы можете просто отклонять слишком много запросов, либо строить очередь для их последующего выполнения, либо комбинировать оба подхода”.

### Bulkhead

Зачем нужен: ***Bulkhead (перегородка)*** – паттерн, призванный изолировать сбой одного компонента от других. Название дано по аналогии с отсеком-толщиной корабля: если корпус пробит, вода затопит лишь один отсек, а корабль останется на плаву. В контексте микросервисов bulkhead изолирует ресурсы (например, потоки или соединения) для разных зависимостей или клиентов. Это предотвращает ситуацию, когда зависший или медленный сервис “душит” все потоки клиента. Например, если клиент A вызывает сервис B и сервис C параллельно, и B начинает тормозить, мы хотим, чтобы большая часть потоков продолжала обрабатывать вызовы к C.

Что делает: Bulkhead препятствует исчерпанию общих ресурсов. Как объясняет Microsoft, в стандартном сценарии большое количество неудачных запросов к одному сервису может “исчерпать соединения или потоки в клиенте; затем клиент перестаёт отправлять запросы не только к проблемному сервису, но и ко всем остальным”. Решение – выделять “отсеки” ресурсов. Например, иметь отдельный пул потоков или семафор для обращений к каждому сервису. Тогда если один отсек (сервис B) полностью занят, остальные (сервис A, C) все равно работают независимо. Этот подход сохраняет функциональность части системы при частичном сбое.

Как работает: В Resilience4j доступны два варианта реализации bulkhead: 
1. SemaphoreBulkhead (семафорный) и FixedThreadPoolBulkhead (фиксированный пул потоков).
2. В первом случае используется семафор – простой механизм, ограничивающий число одновременно выполняющихся вызовов (заявок на семафор).
3. Hystrix может работать аналогично: он предлагает как семафорную изоляцию, так и изоляцию потоков. Однако по умолчанию Hystrix использует изолированный пул потоков для каждой команды, что обеспечивает полную разгрузку исходного потока и таймаут из того пула. Resilience4j же по умолчанию использует семафор, “в отличие от Hystrix не создавая теневой (shadow) пул потоков”. Это упрощает интеграцию – нет лишнего потока, который нужно настраивать.

Например, в Resilience4j можно прописать аннотацию:

```java
@Bulkhead(name = "externalService", type = Bulkhead.Type.SEMAPHORE)
public String callExternal() {
    // код вызова внешнего сервиса
}```
